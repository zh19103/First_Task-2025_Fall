import collections
import re
import os
from typing import Dict, List, Tuple, Any, Union

def train_bpe(input_path: str, vocab_size: int, special_tokens: List[str]) -> Tuple[Dict[int, bytes], List[Tuple[bytes, bytes]]]:

    with open(input_path, 'r', encoding='utf-8') as f:
        text = f.read()

    vocab = {i: bytes([i]) for i in range(256)}
    next_id = 256 

    for token in special_tokens:
    
        token_bytes = token.encode('utf-8')
   
        if token_bytes not in vocab.values():
            vocab[next_id] = token_bytes
            next_id += 1

    words = text.split()

    vocab_freq = {}
    for word in words:
        processed_word = ' '.join(list(word)) + ' </w>'
        vocab_freq[processed_word] = vocab_freq.get(processed_word, 0) + 1

    def get_stats(vocab_freq_dict):
        pairs = collections.defaultdict(int)
        for word, freq in vocab_freq_dict.items():
            symbols = word.split()  
            for i in range(len(symbols) - 1):
                pair = (symbols[i], symbols[i + 1])
                pairs[pair] += freq
        return pairs

    def merge_vocab(pair, vocab_freq_dict):
        first, second = pair
        new_vocab = {}
        pattern = re.compile(r'(?<!\S)' + re.escape(first + ' ' + second) + r'(?!\S)')
        for word, freq in vocab_freq_dict.items():
            new_word = pattern.sub(first + second, word)
            new_vocab[new_word] = freq
        return new_vocab

    merges = []  

    current_merges = 0
    max_merges = vocab_size - len(vocab)  

    for i in range(max_merges):
        pairs = get_stats(vocab_freq)
        if not pairs:
            print(f"没有更多可合并的字节对，提前停止于第{i}次迭代")
            break

        # 选择频率最高的字节对
        best_pair = max(pairs, key=pairs.get)
        best_freq = pairs[best_pair]

        if best_freq < 2:
            print(f"最高频率为{best_freq}，停止合并于第{i}次迭代")
            break

        # 记录合并规则
        merges.append(best_pair)
        # 执行合并，更新词汇频率表
        vocab_freq = merge_vocab(best_pair, vocab_freq)
        current_merges += 1

        if (i + 1) % 50 == 0: 
            print(f"已完成第{i+1}次合并，当前最高频对: {best_pair}, 频率: {best_freq}")

    print(f"BPE训练完成! 总共执行了 {current_merges} 次合并。")
    return vocab, merges

def run_train_bpe(input_path: str, vocab_size: int = 30000, special_tokens: List[str] = None) -> Dict[str, Any]:

    if special_tokens is None:
        special_tokens = ["<|endoftext|>", "<pad>", "</s>", "<unk>", "<mask>"]

    print(f"开始BPE训练...")
    print(f"输入文件: {input_path}")
    print(f"目标词汇量: {vocab_size}")
    print(f"特殊tokens: {special_tokens}")

    try:
        vocab, merges = train_bpe(input_path, vocab_size, special_tokens)

        result = {
            'vocab_size': len(vocab),
            'merges_count': len(merges),
            'vocab_sample': dict(list(vocab.items())[:5]), 
            'merges_sample': merges[:5] if merges else [] 
        }

        print(f"训练成功! 最终词汇量: {len(vocab)}, 合并次数: {len(merges)}")
        return result

    except Exception as e:
        print(f"训练过程中出现错误: {e}")
        return {'error': str(e)}